---
title: 6.1 PID 控制理論
sidebar_position: 1
description: 深入淺出理解 PID 演算法。不講複雜微積分，專注於 VEX V5 實戰：如何消除馬達過衝、實現毫釐不差的精準停靠。
keywords: [PID 控制, VEX PID, 比例積分微分, 機械人演算法, 過衝問題, VEX V5 編程, 自動化控制]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
你的機器人已經「有腦袋」了（第五單元），但它的四肢還未夠協調。

你可能寫過 `spinFor(1000, degrees)`，但因為車身慣性，它最後停在 1050 度；或者你想行直線，卻因為兩邊輪的摩擦力不同，行成了「香蕉線」。

這一章，我們要學習自動化控制領域的「神之公式」：**PID**。別怕，這裡沒有微積分，只有「老司機開車」的故事。

---

## **1. 為什麼單純用馬達內置功能並不夠？**

V5 馬達雖然內置了 PID，但它是「各管各的」（術語叫單關節控制）：
* **只管輪子：** 它只負責令馬達軸轉動指定圈數。
* **不管車身：** 假如輪子在地上**打滑 (Slip)**（空轉），馬達會誤以為自己轉夠了，但車身其實沒移動。
* **不顧協調：** 內置 PID 不會協調兩邊馬達的阻力差，結果就是行歪。

我們需要一個**全域的大腦**來即時修正誤差，這就是我們自己寫 PID 控制器的原因。

---

## **2. PID 三兄弟：老練駕駛的開車方式**

想像你正開車前往紅綠燈路口（目標點 Target）。

### **P (Proportional) 比例項 —— 「路怒症駕駛」**
* **原理：** 離目標越遠，油門踩得越猛。
* **邏輯：** $Error \times kP$。
* **情境：** 離紅燈 100 米，油門踩到底；離紅燈 10 米，放開油門慢慢滑行。
* **缺點：** 容易**過衝 (Overshoot)**。因為車子有慣性，到了停止線才鬆油門是剎不死的。

### **D (Derivative) 微分項 —— 「預測型剎車」**
* **原理：** 看你衝得太快，幫你踩剎車。
* **邏輯：** $(CurrentError - PrevError) \times kD$。這代表了「速度」的反向阻力。
* **情境：** 雖然離紅燈還有距離，但車速太快，D 項會產生阻尼感，提前減速。
* **作用：** 消除震盪，防止過衝。

### **I (Integral) 積分項 —— 「強迫症患者」**
* **原理：** 如果最後差一點點未到位，我就慢慢「磨」過去。
* **邏輯：** $\sum Error \times kI$（累積所有誤差乘以係數）。
* **情境：** P 和 D 配合完美，但車停在離線 2 厘米處，阻力太大推不動。I 會累積憤怒值：「怎麼還未到！」，最後累積足夠力量挪動那最後 2 厘米。
* **注意：** 在 VEX 底盤控制中，**絕大多數時候不需要 I**。加入 I 很容易令機器人「抽風」或瘋狂震盪。

---

## **3. 核心代碼邏輯（偽代碼）**

PID 看起來嚇人，寫出來其實不用 50 行。這是一個標準的「閉迴路控制」循環。
<Tabs>
<TabItem value="vexcode" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 基礎 PID 直線行駛封裝
 * 建議將此函式放在單獨的自定義檔案或 main.cpp 上方
 */

#include "vex.h"
using namespace vex;

// PID 參數 (需根據車重及齒輪比現場調校)
double kP = 0.45; 
double kD = 0.15;

/**
 * @param targetDegrees 目標旋轉角度 (degrees)
 */
void drivePID(double targetDegrees) {
    double error = 0;
    double prevError = 0;
    double derivative = 0;
    double voltage = 0;

    // 1. 重置編碼器數據
    LeftMotor.resetPosition();
    RightMotor.resetPosition();

    // 2. PID 閉迴路循環
    // 當誤差絕對值 > 5 度時持續修正
    while (fabs(targetDegrees - LeftMotor.position(degrees)) > 5) {
        
        // 獲取當前位置並計算誤差 (P)
        double currentPos = LeftMotor.position(degrees);
        error = targetDegrees - currentPos;

        // 計算誤差變化率 (D)，即預測剎車力度
        derivative = error - prevError;

        // 計算輸出電壓 (VEX V5 支援 -12.0 到 12.0 伏特)
        voltage = (error * kP) + (derivative * kD);

        // 3. 輸出至馬達
        // 使用電壓控制 (Volt) 比百分比更線性、精準
        LeftMotor.spin(forward, voltage, volt);
        RightMotor.spin(forward, voltage, volt);

        // 紀錄誤差供下次循環計算
        prevError = error;
        
        // 延時 20ms，與系統感應器刷新率同步
        wait(20, msec);
    }
    
    // 4. 到達目標，強制剎車
    LeftMotor.stop(brake);
    RightMotor.stop(brake);
}
```
</TabItem>

<TabItem value="pros" label="PROS(C++)">

```cpp
/* * PROS 3 - 專業級 PID 控制 (電壓補償版)
 */

#include "main.h"

/**
 * @param target_ticks 目標編碼器數值 (ticks)
 */
void drivePID(double target_ticks) {
    // PROS 使用毫伏 (mV)，因此 kP 數值通常比 VEXcode 大
    double kP = 3.5; 
    double kD = 1.2;
    
    double error = 0;
    double prev_error = 0;
    double derivative = 0;

    // 重置編碼器
    left_mg.tare_position();
    right_mg.tare_position();

    while (true) {
        // 獲取底盤平均編碼器數值
        double avg_pos = (left_mg.get_positions()[0] + right_mg.get_positions()[0]) / 2;
        
        error = target_ticks - avg_pos;
        derivative = error - prev_error;
        
        // 計算電壓輸出，並限制在 ±12000mV (12V) 內
        double output = (error * kP) + (derivative * kD);
        if (output > 12000) output = 12000;
        if (output < -12000) output = -12000;

        left_mg.move_voltage(output);
        right_mg.move_voltage(output);

        // 退出條件優化：
        // 必須同時滿足「誤差夠小」且「速度已慢下來 (D < 2)」，防止慣性過衝
        if (std::abs(error) < 10 && std::abs(derivative) < 2) {
            break;
        }

        prev_error = error;
        pros::delay(20);
    }
    
    // 停止馬達
    left_mg.move_voltage(0);
    right_mg.move_voltage(0);
}
```
</TabItem>
</Tabs>
---

## **4. 🎙️ 評審面談實戰 (Judges Interview)**

**Q1. 為什麼要自己寫 PID，而不使用官方自帶的指令？**
*(考察點：對控制理論的深入理解)*

**🧐 回答範例：**
「官方內置功能無法處理底盤整體的慣性（Momentum）和地面摩擦力的變化。自定義 PID 讓我們能引入 **D（微分項）**，這相當於電子的預測剎車。這讓我們能以極速衝向目標，並在最後一刻精準減速。這對於 15 秒自動程式非常重要，因為我們既要爭分奪秒，又要保證動作精確，消除慣性帶來的過衝（Overshoot）。」

**Q2. 你們是如何調校 PID 參數的？**
*(考察點：工程實作方法與科學調試)*

**🧐 回答範例：**
「我們遵循標準工程流程。首先將 I 和 D 歸零，增加 P 比例項直到系統出現等幅震盪；接著引入 D 微分項來消除震盪，達到**阻尼作用 (Damping)**。我們不會盲目猜測數字，而是在 Brain 螢幕上繪製誤差曲線，根據曲線的波峰和穩定時間來決定增益值的加減。」

---