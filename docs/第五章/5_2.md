---
title: 5.2 遙控優化
sidebar_position: 2
description: 探討如何透過演算法消除遙控器抖動，並利用指數曲線映射（Exponential Mapping）提升操作精確度。
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
在 5.1 章中，我們實現了讓馬達轉動。但若直接將搖桿原始數據傳輸至馬達，機器人的操控感會非常生硬：輕推搖桿即暴衝，微調時卻因靜摩擦力動彈不得。

本章將學習如何透過編程「校正」控制器，讓機器人達成「如臂使指」的操控感。

---

## **1. 消除「死區」(Deadband)：治療遙控器的帕金森症**

V5 控制器的搖桿在回到中央物理位置時，回傳值不一定是完美的 0，通常會在 `-5` 到 `5` 之間跳動。

* **後果：** 即使未觸碰手把，馬達也會發出細微嗡鳴聲或緩慢蠕動，導致馬達在低電壓下異常發熱。
* **解決方案：** 設定 **死區（Deadband）**。若搖桿絕對值小於特定閾值（例如 5），則強制視為 0。



---

## **2. 阻塞 vs 非阻塞 (Blocking vs Non-blocking)**

這是新手最常遇到的邏輯瓶頸，決定了機器人是「回合制」還是「流暢式」運動。

| 類型 | 特性 | 影響 |
| :--- | :--- | :--- |
| **阻塞 (Blocking)** | 程式必須等待馬達動作完全結束（如轉完 360 度）才執行下一行。 | 機器人動作生硬，必須等輪子停下才能動手臂。 |
| **非阻塞 (Non-blocking)** | 發送指令後立即執行下一行，無需等待馬達完成。 | 實現多執行緒（Multithreading）效果，可邊跑邊採集。 |

**實戰原則：** 在手動控制階段（Driver Control），務必使用**非阻塞式**指令，以維持操作靈敏度。

---

## **3. 指數驅動曲線 (Exponential Drive)：老手的秘密**

線性映射（搖桿推 50% = 馬達轉 50%）在精細操作時容錯率極低。為了解決此問題，我們引入 **指數曲線映射**。

* **原理：** 將輸入值（0-1.0）進行立方運算。由於小數越乘越小，這會大幅壓縮中低速區間的靈敏度。
* **效果：** * **微調時：** 搖桿推 50% 時，輸出僅為 $0.5^3 = 12.5\%$。機器人移動極為緩慢，便於對準目標（Goal）。
    * **衝刺時：** 搖桿推 100% 時，輸出依然是 $1.0^3 = 100\%$。最高速性能不受影響。



---

## **4. 代碼實作對比**

以下代碼展示如何實作具備「死區過濾」與「三次方曲線映射」的遙控邏輯。

<Tabs>
<TabItem value="vexcode" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 指數曲線與死區優化
 */

#include "vex.h"
#include <cmath> // 用於 pow 運算
using namespace vex;

void usercontrol(void) {
    while (true) {
        // 獲取原始搖桿值 (-100 到 100)
        double stickInput = Controller1.Axis3.position();
        double finalOutput = 0;

        // 1. 死區過濾 (Deadband)
        if (std::abs(stickInput) > 5) {
            // 2. 指數曲線轉換：(Input/100)^3 * 100
            // 簡化公式：Input^3 / 10000
            finalOutput = std::pow(stickInput, 3) / 10000.0;
        }

        leftMotor.spin(forward, finalOutput, percent);
        wait(20, msec);
    }
}
```
</TabItem> 

<TabItem value="pros4" label="PROS 4">

```cpp
/* * PROS 4 - 指數曲線與電壓精準控制
 */

#include "main.h"
#include <cmath>

void opcontrol() {
    pros::Controller master(pros::E_CONTROLLER_MASTER);
    pros::Motor left_mtr(1);

    while (true) {
        // PROS 搖桿範圍為 -127 到 127
        double input = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);

        if (std::abs(input) > 5) {
            left_mtr.move(input);
        }
        pros::delay(20);
    }
}
```
</TabItem> 
</Tabs>

🎤 評審面談實戰 (Judges Interview)
Q1: 操作員反應機器人過於靈敏，難以精準瞄準得分區，你們如何解決？ (考察重點：控制演算法應用與操作反饋)

🧐 回答範例： 「我們並未調降馬達的最高輸出功率，而是引入了指數曲線映射（Exponential Curve Mapping）。透過將搖桿輸入進行三次方運算，我們大幅擴展了搖桿中心區域的低速控制精度，讓操作員能進行像素級別的微調；同時在搖桿推到底時仍保有 100% 的速度，兼顧了精準對位與全場機動性。」

Q2: 為什麼機器人在自動程式中，動作與動作之間會有不明顯的停頓？ (考察重點：阻塞式與非阻塞式代碼的理解)

🧐 回答範例： 「這通常是因為使用了阻塞式指令（Blocking Commands），例如 waitForCompletion=true 的參數設定。這會強制 CPU 暫停，直到當前物理動作結束才執行下一行代碼。在優化版本中，我們全面改用非阻塞模式，配合狀態機邏輯，讓底盤移動與機械手臂抬升可以平行運作，消除了不必要的待機時間。」