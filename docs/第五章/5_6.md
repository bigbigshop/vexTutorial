---
title: 5.6 狀態機(FSM)
sidebar_position: 6
description: 學習如何利用有限狀態機 (FSM) 簡化複雜控制邏輯，告別纏繞的 if-else 語句，實現自動吸取與持有等高階功能。
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
你的機器人現在已經擁有了強壯的底盤（5.3）、敏銳的感應器（5.4），甚至學會了執行自動劇本（5.5）。

但是，當你試圖結合這一切時，問題就來了。例如：「按下 L1 啟動吸入；如果吸到方塊，自動停下並夾緊；如果按下 R1，則吐出」。你會發現用一般的 `if` 語句寫起來非常痛苦，邏輯稍微增加，程式碼就會變成亂成一團的「義大利麵」。

這一章，我們要引入軟體工程中的核心武器：**狀態機 (State Machine)**。

---

## **1. 為什麼 if-else 是「義大利麵代碼」？**

想像你還在用傳統寫法控制吸取裝置（Intake）：
1. 如果按 L1，正轉。
2. 如果按 L2，反轉。
3. 如果都沒按，停止。

這看起來沒問題。但如果需求變成：「按一下 L1 就持續吸入，直到感應器偵測到方塊才自動停止並夾緊」。你的 `if` 會變成：「如果按了 L1，或者之前按過 L1 且沒看到方塊，且沒有按 L2...」

這種邏輯纏繞在一起、牽一髮而動全身的寫法，就是 **Spaghetti Code**。

---

## **2. 什麼是狀態機？**

狀態機的核心思想是：**機器人一次只能處於一種狀態。**

對於吸取裝置，它可以被拆解為以下幾種狀態（State）：
* **待機 (IDLE)：** 什麼都不做。
* **搜尋 (SEARCHING)：** 滾筒快速轉動，主動尋找方塊。
* **持有 (HOLDING)：** 感應到方塊了，輕輕用力夾住不讓它掉落。
* **吐出 (OUTTAKING)：** 反轉滾筒。

狀態機的魔法在於：我們將 **「我在哪」（State）**和**「我要怎麼變」（Transition，狀態轉換）** 徹底分開。

<Tabs> <TabItem value="vexcode" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 有限狀態機 (FSM) 吸取系統
 */

#include "vex.h"
using namespace vex;

// 1. 定義所有可能的狀態
enum IntakeState {
    IDLE,       // 待機
    SEARCHING,  // 正在吸入
    HOLDING,    // 偵測到物體，主動夾緊
    OUTTAKING   // 正在吐出
};

// 紀錄當前狀態
IntakeState currentState = IDLE;

void usercontrol(void) {
    while (1) {
        // --- 第一部分：狀態轉移邏輯 (大腦判斷) ---
        if (Controller1.ButtonL1.pressing()) {
            currentState = SEARCHING;
        } 
        else if (Controller1.ButtonR1.pressing()) {
            currentState = OUTTAKING;
        } 
        else if (Controller1.ButtonB.pressing()) {
            currentState = IDLE;
        }
        // 自動化邏輯：如果正在吸入且距離感應器發現目標 < 50mm
        else if (currentState == SEARCHING && Distance1.objectDistance(mm) < 50) {
            currentState = HOLDING;
        }

        // --- 第二部分：狀態執行邏輯 (肢體動作) ---
        switch (currentState) {
            case SEARCHING:
                IntakeMotor.spin(forward, 100, percent);
                break;
            case OUTTAKING:
                IntakeMotor.spin(reverse, 100, percent);
                break;
            case HOLDING:
                // 使用低功率保持咬合，防止方塊掉落
                IntakeMotor.spin(forward, 15, percent); 
                break;
            case IDLE:
            default:
                IntakeMotor.stop(coast);
                break;
        }

        wait(20, msec);
    }
}
```
</TabItem>

<TabItem value="pros" label="PROS(C++)">

```cpp
/* * PROS 3 - 基於 Enum 的狀態機控制
 */

#include "main.h"

// 1. 定義狀態類型
enum class IntakeState {
    IDLE,
    SEARCHING,
    HOLDING,
    OUTTAKING
};

void opcontrol() {
    pros::Motor intake(1);
    pros::Distance dist_sensor(2);
    pros::Controller master(pros::E_CONTROLLER_MASTER);
    
    IntakeState currentState = IntakeState::IDLE;

    while (true) {
        // --- 狀態轉換 (Transitions) ---
        if (master.get_digital(DIGITAL_L1)) {
            currentState = IntakeState::SEARCHING;
        } else if (master.get_digital(DIGITAL_R1)) {
            currentState = IntakeState::OUTTAKING;
        } else if (master.get_digital(DIGITAL_B)) {
            currentState = IntakeState::IDLE;
        } else if (currentState == IntakeState::SEARCHING && dist_sensor.get() < 50) {
            currentState = IntakeState::HOLDING;
        }

        // --- 狀態動作 (Actions) ---
        switch (currentState) {
            case IntakeState::SEARCHING:
                intake.move(127); // 全速
                break;
            case IntakeState::OUTTAKING:
                intake.move(-127);
                break;
            case IntakeState::HOLDING:
                intake.move(20); // 微弱電力保持
                break;
            case IntakeState::IDLE:
                intake.move(0);
                break;
        }

        pros::delay(20);
    }
}
```
</TabItem> </Tabs>

---

## **3. 邏輯架構：switch-case 的藝術**

我們利用 C++ 的 `enum`（列舉）來定義狀態名稱，並透過 `switch` 語句來執行動作。

### **開發三部曲：**
1.  **定義狀態：** 給每個行為取個清晰的名字（如 `IDLE`, `SEARCHING`），而不是用 0, 1, 2 這些無意義的數字。
2.  **狀態管理（大腦）：** 只負責判斷「什麼時候該切換狀態」。例如「按了按鈕」或「感應器偵測到物體」。
3.  **執行動作（肢體）：** 只負責根據目前的狀態來轉動馬達。

---

## **4. 為什麼要這麼大費周章？**

雖然程式碼結構看起來變複雜了，但帶來了質的飛躍：
1.  **邏輯清晰：** 你一眼就能看出機器人有幾種模式。
2.  **自動流程：** 「看到方塊自動切換到持有狀態」這類邏輯在狀態機裡只是一行轉換條件，不會干擾到其他按鈕邏輯。
3.  **易於擴充：** 如果想新增一個「防卡死模式」，只需要增加一個 `case JAMMED`，完全不會破壞既有程式碼。

---

## **5. 第五單元結業總結：從「廢鐵」到「智能實體」**

恭喜你！你已經完成了 VEX 機器人最神奇的蛻變。
* ✅ **拒絕死板：** 學會了非阻塞程式碼，讓機器人能「一心多用」。
* ✅ **賦予感官：** 裝上了慣性與視覺感應器，讓機器人擁有方向感與辨色力。
* ✅ **編寫劇本：** 用封裝函式拿到了珍貴的 15 秒自動獎勵分。
* ✅ **注入邏輯：** 掌握了狀態機，讓複雜動作變成了一鍵觸發的本能。

**但是......它還不夠「極致」。**
你是否發現自動程式跑 10 次仍有 2 次會歪？馬達編碼器真的能代表真實位移嗎？這就是我們下一單元 **模組 6：演算法進階** 的課題。



---

## **🎤 評審面談實戰 (Judges Interview)**

**Q1. 你們如何管理自動化程式中的複雜動作邏輯？**
*(考察重點：軟體架構思維)*

**🧐 回答範例：**
「我們採用了 **有限狀態機 (Finite State Machine, FSM)** 架構。我們將機器人的行為拆解成離散的狀態，例如『搜尋』、『持球』、『得分』。透過 `switch-case` 結構，我們清楚定義了每個狀態的行為以及切換條件。這不僅提高了程式碼的可讀性，還讓我們能輕鬆實現 **Auto-Indexing (自動編目)** 等高階功能。」

**Q2. 你們的吸取裝置按一下就能自動吸滿，這是怎麼做到的？**
*(考察重點：感應器與狀態機的結合)*

**🧐 回答範例：**
「這是狀態機與距離感應器的結合。我們定義了一個**轉移條件 (Transition Condition)**：當感應器偵測到物體距離小於 50mm 時，狀態會自動從 `SEARCHING` 切換到 `HOLDING`。這讓操作員只需按一下按鈕，機器人就會自動接手剩餘工作，極大地減少了操作員的**認知負荷 (Cognitive Load)**。」

---