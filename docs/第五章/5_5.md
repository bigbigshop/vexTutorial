---
title: 5.5 自動程式：從「亂碼」到「腳本」
sidebar_position: 5
description: 學習如何撰寫高品質的 VEX 15 秒自動競賽程式，透過 C++ 函式封裝與邏輯解耦，告別混亂的程式碼，打造穩定且易於維護的自動控制腳本。
keywords: [VEX 自動程式, Autonomous Period, 15秒自動, 程式碼封裝, 函式優化, VEX 競賽策略, VEXcode Pro V5, PROS 4]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
你的機器人現在有了強壯的底盤、敏銳的「內耳」（慣性感應器）和看路的「眼睛」（視覺/距離感應器）。現在萬事俱備，只差一份**劇本**。

這一章我們要挑戰 VEX 比賽中最讓人心跳加速的環節：**前 15 秒的自主控制階段 (Autonomous Period)**。如果不拿下自動階段的獎勵分數 (WP)，你很難在排名賽中名列前茅。

---

## **1. 拒絕「義大利麵式程式碼」(Spaghetti Code)**

這是 99% 新手都會犯的錯誤。想像你要機器人：前進 1 米 -> 右轉 90 度 -> 吐出方塊。

**新手典型的錯誤寫法：**
如果不進行封裝，你必須為每一顆馬達寫下獨立指令。這會導致以下致命問題：

1.  **必須成對修改：** 如果想改前進距離，你必須同時修改左、右馬達兩行代碼。手滑改錯一行，機器人就會原地打轉。
2.  **布林值陷阱 (Blocking)：** 像 `true` 或 `false` 這種阻塞設定，一旦放錯位置，機器人會先動左輪、停下後才動右輪，走起來像個「跛腳的人」。
3.  **難以維護：** 只要自動程式超過 50 行，這些重複且易錯的指令會像一團亂麻（義大利麵）一樣困住你。

---

## **2. 核心大招：封裝 (Encapsulation)**

解決方法是將囉唆的指令「打包」成簡單的自定義功能。這在編程中稱為 **API 封裝**。

與其對機器人說：「左腿收縮 50%，右腿收縮 50%，持續 2 秒」，不如直接創造屬於自己的語言：`driveForward(100);`。

### **封裝的邏輯步驟：**
1.  **打造工具：** 在主程序上方或獨立文件中撰寫處理馬達同步的自定義函式。
2.  **簡化調用：** 在 `autonomous` 函式中像寫英文腳本一樣調用這些功能。

<Tabs>
<TabItem value="vexcode" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 運動功能封裝實作
 */

#include "vex.h"
using namespace vex;

// 1. 前進功能封裝
// dist: 目標旋轉角度, speed: 速度百分比
void driveForward(double dist, double speed) {
    LeftMotor.setVelocity(speed, percent);
    RightMotor.insertVelocity(speed, percent);
    
    // 使用 false 讓左輪非阻塞啟動，true 讓右輪阻塞直到完成，實現同步
    LeftMotor.spinFor(forward, dist, degrees, false);
    RightMotor.spinFor(forward, dist, degrees, true);
}

// 2. 轉向功能封裝 (基於編碼器)
void turnRight(double dist, double speed) {
    LeftMotor.spinFor(forward, dist, degrees, false);
    RightMotor.spinFor(reverse, dist, degrees, true);
}

// 3. 採集器控制
void setIntake(int speed) {
    IntakeMotor.spin(forward, speed, percent);
}

void autonomous(void) {
    // 像寫劇本一樣編寫 15 秒動作
    driveForward(1000, 80);  // 前進 1000 度，速度 80%
    setIntake(100);          // 開啟採集
    wait(500, msec);         // 等待 0.5 秒
    driveForward(-500, 50);  // 倒車
    turnRight(300, 50);      // 右轉
}
```
</TabItem><TabItem value="pros" label="PROS(C++)">

```cpp
/* * PROS 3 - 使用物件導向風格封裝運動
 */

#include "main.h"

// 定義全局馬達組 (假設端口已在 main.h 設定)
pros::Motor_Group left_mg({1, 2});
pros::Motor_Group right_mg({-3, -4});

// 1. 前進功能封裝 (使用電壓控制更穩定)
void drive(int dist, int voltage) {
    // 重置編碼器
    left_mg.tare_position();
    right_mg.tare_position();
    
    // 簡單的目標值追蹤
    left_mg.move_relative(dist, voltage / 100); // PROS move_relative 使用速度
    right_mg.move_relative(dist, voltage / 100);
    
    // 等待到達目標 (阻塞邏輯)
    while (!((left_mg.get_positions()[0] < dist + 5) && (left_mg.get_positions()[0] > dist - 5))) {
        pros::delay(20);
    }
}

// 2. 原地轉向
void turn(int dist, int voltage) {
    left_mg.move_relative(dist, voltage / 100);
    right_mg.move_relative(-dist, voltage / 100);
    // 此處需加入類似 drive() 的等待邏輯
}

void autonomous() {
    // 調用 API
    drive(1500, 8000); // 前進 1500 ticks，電壓 8000mV
    turn(400, 6000);   // 轉向
    drive(-1000, 8000); // 後退
}
```
</TabItem></Tabs>



---

## **3. 15 秒腳本：像寫文章一樣寫代碼**

當你完成封裝後，你的 `autonomous` 函式會變得無比清晰。

**實戰腳本範例：**
1.  **衝刺：** 搶奪中間的目標物。
2.  **採集：** 開啟採集器夾住方塊。
3.  **定位：** 後退並轉身瞄準得分區。

**封裝後的優勢：**
* **易讀：** 即使是非編程背景的隊員也能一眼看出機器人在做什麼。
* **易改：** 修改距離只需要動一個數字，不需要在幾百行代碼中搜索馬達編號。
* **重用：** 寫一次運動邏輯，整個賽季的所有自動程式都能共用。

---

## **4. 偵錯的藝術：參數調校 (Tuning)**

程式碼寫好了，第一次執行通常是災難：設定 90 度卻轉了 120 度。這通常不是邏輯錯了，而是物理**參數 (Parameters)** 未校準。

**實戰技巧：**
* **逐步測試：** 不要一次跑完 15 秒。先校準第一步「衝刺」，準確後再調校第二步「轉身」。
* **實體測量：** 拿捲尺量度。如果機器人偏左，檢查左輪摩擦力是否過大。
* **現場微調：** 比賽現場場地摩擦力會變，強隊通常會在手柄螢幕寫簡單選單，現場快速修改參數。

---

## **🎤 評審面談實戰 (Judges Interview)**

**Q1. 你們的自動程式碼非常整潔，你們是如何組織程式碼結構的？**
*(考察重點：軟體工程思維／抽象化能力)*

**🧐 回答範例：**
「我們採用了**模組化封裝 (Modular Encapsulation)** 的設計理念。我們不希望在主程式看到底層馬達指令，因為那樣難以閱讀且易出錯。我們構建了自己的**運動函式庫**，將前進、轉向、採集等動作包裝成簡單的 API。這讓我們的自動程式讀起來像英文句子，隊員能快速理解邏輯，現場修改參數也只需幾秒鐘。」

**Q2. 你們如何保證自動程式每次執行動作時都能維持一致性？**
*(考察重點：閉迴路控制／感應器依賴)*

**🧐 回答範例：**
「關鍵在於減少對『時間』的依賴，增加對 **『感應器回饋』** 的依賴。在封裝函式中，我們結合了慣性感應器。例如 `turnRight(90)` 不只是讓馬達轉圈，而是即時讀取角度。如果因為摩擦力轉多了，函式會自動修正。這種 **閉迴路控制 (Closed-loop Control)** 保證了即使電池電量不同，動作也能保持一致。」

---