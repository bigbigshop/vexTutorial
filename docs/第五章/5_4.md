---
title: 5.4 視覺與距離感應器
sidebar_position: 4
description: 探索 VEX V5 視覺感應器 (Vision Sensor) 的色塊追蹤技術與距離感應器 (Distance Sensor) 的精確測距應用，實現更智能的閉迴路自動控制系統。
keywords: [VEX Vision Sensor, 視覺感應器教學, Distance Sensor, 距離感應器, 色塊追蹤, 閉迴路控制, VEX V5 自動化]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
在 5.3 章，我們為機器人裝上了「內耳」（慣性感知器），讓它閉著眼睛也能走直線。但若想成為真正的自動駕駛「老司機」，只有內耳是不夠的。機器人還需要「眼睛」去找色塊，需要「觸鬚」去感知障礙物。

這一章，我們要來玩轉 **視覺感應器 (Vision Sensor)** 和 **距離感應器 (Distance Sensor)**。

---

## **1. 視覺感應器：機器人的「色塊追蹤器」**

別被名字騙了，VEX 的視覺感應器並不能像人眼一樣看清楚世界，它本質上是一個高級的「顏色追蹤器」。

* **它能做的事：** 在畫面中找到你設定好的色塊（如紅色），並回傳它在螢幕上的位置（X, Y 座標）及大小（Width, Height）。
* **它不能做的事：** 分辨形狀（分不清圓球和方塊，只認顏色）、辨識紋理、或在黑暗中工作。

### **核心概念：單色辨識 (Signature) vs 色碼辨識 (Color Code)**

1.  **Color Signature（單色辨識）：** 最基本模式。對著目標「鎖定」顏色。
    * **缺點：** 易受干擾。場地外觀眾的紅衣服、紅椅子都可能導致誤判。
2.  **Color Code（色碼辨識）：** 進階技巧。告訴感應器：「只有當紅色和綠色緊鄰時，才算目標」。
    * **優點：** 抗干擾能力極強，大幅減少誤判。

:::warning
> **⚠️ 致命陷阱：光照環境**
> 比賽現場的燈光亮度或陰影與實驗室不同，顏色數值會改變。**實戰準則：** 永遠不要相信實驗室數據，必須在比賽現場重新校準 (Signature)。
:::


---

## **2. 距離感應器：告別「盲測」時裝控制**

距離感應器發射激光 (Laser) 測量前方物體距離。在自動程式 (Autonomous) 裡，它最大的作用是把**「猜時間」變成「量距離」**。

### **情境還原：為什麼你的自動程式總是不準？**
許多新手喜歡用時間控制：`drive(forward); wait(2, sec); stop();`
* **滿電時：** 2 秒跑了 1.2 米，直接撞牆。
* **低電時：** 2 秒只跑了 0.8 米，還沒碰到目標就停了。
* **結果：** 你的自動程式完全是靠運氣。

**實戰解法：** 使用距離感應器充當「電子眼」。只要距離大於 100mm 就一直跑，一旦夠近了就立刻煞車。這就是「閉迴路控制」的雛形——不靠猜測，而是靠測量。



---

## **3. 代碼實作：自動追蹤與精準停靠**

我們將實作兩個核心功能：利用視覺感應器追蹤目標 X 座標，以及利用距離感應器實作防撞煞車。

<Tabs>
<TabItem value="vexcode" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 視覺追蹤與距離控制實作
 */

#include "vex.h"
using namespace vex;

void autonomous(void) {
    // 1. 距離感應器：精準停靠邏輯
    // 只要距離牆壁大於 100 毫米，就繼續跑
    while (DistanceSensor.objectDistance(mm) > 100) {
        Drivetrain.drive(forward, 50, percent);
        wait(20, msec); // 讓 CPU 喘口氣
    }
    Drivetrain.stop(brake);

    // 2. 視覺感應器：P 控制追蹤 (虛擬架構)
    while (true) {
        VisionSensor.takeSnapshot(RED_BLOCK);
        if (VisionSensor.objectCount > 0) {
            // 中心點 X 座標為 158
            int error = VisionSensor.largestObject.centerX - 158;
            int turn = error * 0.5; // P 修正力度

            LeftMotor.spin(forward, 50 + turn, percent);
            RightMotor.spin(forward, 50 - turn, percent);
        } else {
            // 沒看到目標？原地旋轉尋找
            LeftMotor.spin(forward, 30, percent);
            RightMotor.spin(reverse, 30, percent);
        }
        wait(20, msec);
    }
}
```
</TabItem>

<TabItem value="pros" label="PROS(C++)">

```cpp
/* * PROS - 使用 Distance 與 Vision 進行閉迴路控制
 */

#include "main.h"

void autonomous() {
    pros::Distance dist_sensor(11);
    pros::Vision vis_sensor(12);

    // 1. 距離控制
    while (dist_sensor.get() > 100) {
        left_mg.move(60);
        right_mg.move(60);
        pros::delay(20);
    }
    left_mg.brake();
    right_mg.brake();

    // 2. 視覺追蹤
    while (true) {
        vision_object_s_t obj = vis_sensor.get_by_sig(0, 1); // 取得 Signature 1
        if (vis_sensor.get_object_count() > 0) {
            int error = obj.x_middle_coord - 158;
            int turn = error * 0.6;

            left_mg.move(50 + turn);
            right_mg.move(50 - turn);
        }
        pros::delay(20);
    }
}
```
</TabItem> 
</Tabs>

---

## **🎤 評審面談實戰 (Judges Interview)**
Q1. 你們提到視覺感應器受光照影響很大，你們是如何確保比賽時穩定的？ (考察重點：工程容錯性)

🧐 回答範例： 「我們採取了三層保障策略。第一，我們在攝影鏡頭周圍加裝了自製的遮光罩，減少環境散射光線干擾。第二，我們主要使用顏色編碼 (Color Codes) 而非單一顏色，利用顏色組合（如紅配綠）來過濾雜訊。第三，我們在程式中寫了校準介面，上場前隊員會根據現場光線即時更新顏色閾值。」

Q2. 你們為什麼在自動程式裡使用距離感應器，而不是直接設定時間？ (考察重點：控制理論基礎)

🧐 回答範例： 「因為以時間為基礎 (Time-based) 的控制非常不穩定。電池電壓下降會導致馬達功率降低，同樣的『2 秒鐘』，滿電和低電跑出的距離完全不同。使用距離感應器可以實現閉迴路控制，讓我們能基於實際物理數據（如與目標距離）來決定何時停止，確保動作的一致性。」