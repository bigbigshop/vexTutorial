---
title: 6.3 Odometry：里程計
sidebar_position: 3
description: 學習 VEX 演算法的皇冠明珠 —— 里程計 (Odometry)。透過獨立追蹤輪 (Tracking Wheels) 解決馬達打滑與碰撞位移，實現精準的 X, Y 全域座標導航。
keywords: [Odometry, 里程計, VEX 座標定位, 追蹤輪, Tracking Wheels, 打滑修正, 機械人導航, 全域座標]
---

## **前情提要**
在 6.2 章，我們利用 PID 讓機器人學會了「行直線」。但還有一個致命問題：**打滑 (Wheel Slip)**。

當機器人全速衝向障礙物，或者被對手撞擊側移時，馬達雖然在轉，編碼器持續計數，但機器人實際上並沒有移動。這會導致機器人以為自己到了終點，其實還在半途。這一章，我們要引入 VEX 演算法的皇冠明珠 —— **里程計 (Odometry)**。

---

## **1. 為什麼馬達編碼器會「講大話」？**

我們之前的程式碼都是基於馬達內置編碼器數據，但在實戰中，這些數據經常不可信：

1.  **原地空轉 (Burnout)：** 機器人卡在牆邊，驅動輪瘋狂轉動。編碼器顯示行了 10 米，但實際上一寸都沒動。
2.  **被動位移 (Drift)：** 你鎖死了煞車，但被對手橫向推開。輪子沒轉，編碼器顯示 0，但你的位置已經變了。
3.  **起步打滑 (Slip)：** 猛然啟動時，輪子會像賽車一樣空轉半圈才抓地。這半圈的數據就是誤差。

**結論：** 驅動輪負責推動機器人，會受力打滑。要精準測量距離，你需要一套獨立、不帶動力的量測系統。

---

## **2. 誠實的觀察者：追蹤輪 (Tracking Wheels)**

解決方案是安裝「死輪」（Dead Wheels），學名 **追蹤輪 (Tracking Wheels)**。

這些輪子有三個核心特點：
* **無動力 (Unpowered)：** 不連接馬達，只連接獨立的**旋轉感應器 (Rotation Sensor)**。
* **彈簧壓緊 (Spring-loaded)：** 利用彈簧結構將輪子緊壓地面，確保永遠不會懸空。
* **全向輪 (Omni)：** 使用 Omni 輪以減少摩擦力，且不干擾底盤轉向。



**原理：** 追蹤輪是被動拖著走的。只有當底盤真正移動時，它們才會轉動。如果馬達空轉，追蹤輪是不會動的。它是絕對誠實的數據來源。

---

## **3. 數學原理**

里程計的核心任務是即時計算機器人在場地上的**絕對座標 $(x, y)$** 與 **朝向角度 $\theta$**。這聽起來像微積分，其實就是「無窮加法」。

### **微元法邏輯 (The Logic of Integration)：**

#### **第一步：計算局部位移與角度變化**
在極短的時間（如 10ms）內，我們紀錄左右追蹤輪的位移變化量：

* **局部線位移 ($\Delta d$)：** 左右追蹤輪移動距離的平均值。
  $$\Delta d = \frac{\Delta L + \Delta R}{2}$$
* **局部角位移 ($\Delta \theta$)：** 左右追蹤輪的位移差除以兩輪之間的距離 ($s$)。
  $$\Delta \theta = \frac{\Delta L - \Delta R}{s}$$



#### **第二步：座標轉換 (Global Coordinate Transformation)**
我們需要將機器人自身的相對位移，轉換為場地座標系的 $X$ 和 $Y$。為了提高精度，我們通常使用該時間段內的平均角度 $\theta_{avg} = \theta_{old} + \frac{\Delta \theta}{2}$：

* **場地 X 軸增量：** $\Delta x = \Delta d \times \cos(\theta_{avg})$
* **場地 Y 軸增量：** $\Delta y = \Delta d \times \sin(\theta_{avg})$

#### **第三步：累積總量**
不斷將微小的變化加進總座標中：
* $x_{new} = x_{old} + \Delta x$
* $y_{new} = y_{old} + \Delta y$
* $\theta_{new} = \theta_{old} + \Delta \theta$

---

## **4. 硬體設計：2 輪 vs 3 輪**

| 方案 | 配置 | 優點 | 缺點 |
| :--- | :--- | :--- | :--- |
| **3 輪里程計** | 左輪 + 右輪 + 後輪 (橫向) | 可測量橫向側滑 (Strafing) | 結構非常複雜、佔用空間大 |
| **2 輪 + IMU** | 左輪 + 右輪 + 慣性感應器 | 結構簡單、佔用空間小 | 側滑測量較弱 (Tank Drive 可忽略) |

**實戰建議：** 對於大多數 Tank Drive 底盤，建議採用 **「雙輪 + 慣性感應器 (IMU)」**。V5 的 IMU 非常精準，可以直接提供 $\theta$ 數據，省去由輪速計算角度的誤差。

---

## **5. 軟體實作：主流函式庫 (Templates) 介紹**

理解原理後，我強烈建議新手**不要**從零開始寫數學庫。現時學界都有成熟的 **Template** 供大家使用：

| 函式庫名稱 | 支援環境 | 特點與網結 |
| :--- | :--- | :--- |
| [**LemLib**](https://github.com/LemLib/LemLib) | **PROS** | 全球最受歡迎。提供高度封裝的 Odometry 與運動演算法（如 Pure Pursuit）。 |
| [**EZ-Template**](https://ez-robotics.github.io/EZ-Template/) | **PROS** | 強調易用與快速上手。其 PID 校準介面與自定義 Task 管理非常適合比賽現場微調。 |
| [**Lightninglib**](https://github.com/HectorAlonso18/Lightninglib/) | **PROS** | 提供了一套完整的運動控制方案，包括路徑跟蹤與感應器過濾。 |
| [**MikLib**](https://github.com/EthanMik/mikLib) | **PROS** | 高效率代碼架構。內置 Asynchronous 運動控制器，適合追求流暢路徑與代碼簡潔的用家。 |
| [**RW-Template**](https://github.com/richardbwang/RW-Template) | **VEXcode / PROS** | **香港本地開發**。高階自主機器人模板，專注於精確的運動規劃。支援多種感測器配置，適合需要強大適應性的團隊。 |
| [**JAR-Template**](https://github.com/JacksonAreaRobotics/JAR-Template) | **VEXcode** | 專為 VEXcode Pro V5 設計。提供易於配置的 2 輪/3 輪 Odom 選項與 PID 控制器。 |

**代碼風格對比：**
* **以前 (盲目運行)：** `LeftMotor.spinFor(1000, degrees);`
* **現在 (智慧導航)：** `chassis.moveToPoint(200, 1000, 2000);` (自動行去座標 X:200, Y:1000)。

---

## **🎤 評審面談實戰 (Judges Interview)**

**Q1. 你們為什麼需要里程計？直接用馬達編碼器不行嗎？**
*(考察重點：對誤差來源的深刻理解)*

**🧐 回答範例：**
「馬達編碼器量度的是驅動輪的旋轉，而非底盤的實際位移。在防守和碰撞激烈的比賽中，輪胎打滑 (Wheel Slip) 是必然發生的。如果只依賴馬達，一旦打滑，座標系統就會崩潰。我們使用了獨立的**無動力追蹤輪 (Tracking Wheels)**，它不參與驅動，只負責跟隨地面移動。這讓我們實現了『絕對定位』，即使機器人被推開，它依然清楚自己在場上的位置。」

**Q2. 你們採用哪種里程計配置？為什麼？**
*(考察重點：工程權衡 Engineering Trade-off)*

**🧐 回答範例：**
「我們採用了『雙輪 + 慣性感應器 (IMU)』的方案。雖然三輪配置能測量側移，但我們使用的是 Tank Drive 底盤，橫向打滑極少。同時 V5 IMU 的精度已經足夠應對旋轉角度。我們選擇減少一個機械結構以降低故障率，並節省空間給吸取裝置。這是一個基於 **K.I.S.S. (Keep It Simple, Stupid)** 原則的工程決策。」