---
title: 5.3 慣性感應器(IMU)
sidebar_position: 3
description: 深入了解 V5 慣性感應器 (Inertial Sensor) 的原理與應用，學習如何解決底盤打滑問題，並實作 P 控制器進行自動航向修正與精確轉向。
keywords: [VEX Inertial Sensor, IMU 原理, V5 感應器, 航向修正, 自動程式轉向, P 控制器, 機械人平衡, VEX 教學]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **前情提要**
在 5.2 章中，我們學會了用搖桿控制機器人。但你很快會發現一個問題：在手控階段，你可以靠眼睛修正方向；但在**自動階段 (Autonomous)**，機器人就像閉著眼睛走路，走著走著就歪了。

特別是在對抗激烈的賽季，輪子起步稍微打滑，車頭歪了機器人也渾然不知。這一章，我們要給機器人裝上「內耳」——**慣性感應器 (Inertial Sensor)**，讓它擁有絕對的方向感。

---

## **1. 它是誰：機器人的「平衡器官」**

慣性感應器（Inertial Sensor / IMU）是 V5 套件裡最重要的感應器，沒有之一。它就像人耳深處負責平衡的器官，能告訴機器人：**你在哪、你歪了沒、你是否被撞翻了。**

### **為什麼馬達內置編碼器 (Encoder) 不夠用？**
因為**輪子會打滑**。當你的機器人頂在牆上空轉，或者被對手推著側移時，輪子轉了，但車子沒動。這時候編碼器的數據就是「假數據」。而慣性感應器測量的是車身實際的轉動，它從不說謊。

* **手控階段：** 操作員有眼睛。看到車身偏了會下意識修正。
* **自動階段：** 機器人是瞎的。沒有感應器，它轉彎轉了 85 度還是 95 度完全無法感知。對於想拿下自動獎勵 (WP) 或技能賽冠軍的隊伍來說，這是不不可或缺的。



---

## **2. 儀式感：校準 (Calibration)**

這是 90% 新手發生「鬼打牆」現象的主因。慣性感應器在啟動供電的瞬間，需要定義什麼是「靜止狀態」。

* **禁忌：** 如果程式剛啟動時你在移動機器人，或者重重地將機器人摔在地上，感應器就會校準失敗。
* **結果：** 機器人一啟動就瘋狂原地打轉，或者走直線像蛇一樣彎曲。

**實戰守則：** 開啟電源後，手放開，讓機器人靜靜地「思考人生」2-3 秒。看到螢幕上的校準圖示消失後，再執行程式。

---

## **3. 理解數據：Rotation vs Heading**

在調用讀數時，你會看到兩個很像的函式。選錯了，你的自走程式就會出事。

1.  **`heading()` (羅盤模式)：** 範圍 0 到 360 度。轉完一圈後，359 會變回 0。
    * *用途：* 判斷絕對方向（例如「朝著球門」）。
2.  **`rotation()` (累積模式)：** 範圍無限。向右轉兩圈會顯示 720 度。
    * *用途：* 用於運動控制演算法。處理「359 度跨越到 1 度」的跨零點數學問題非常頭痛，新手建議直接選擇 `rotation()`。

---

## **4. 代碼實作：初始化與航向修正**

我們將實作兩個核心邏輯：一是確保感應器正確校準，二是利用簡單的**比例控制 (P Control)** 讓機器人在行進中被撞偏後，能自動鎖定目標方向。

<Tabs>
<TabItem value="vexcodePro" label="VEXcode Pro V5" default>

```cpp
/* * VEXcode Pro V5 - 慣性感應器校準與航向鎖定
 */

#include "vex.h"
using namespace vex;

void autonomous(void) {
    // 1. 初始化校準 (必須放在所有動作之前)
    Inertial1.calibrate();
    
    // 等待校準完成，這期間嚴禁觸碰機器人
    while (Inertial1.isCalibrating()) {
        wait(100, msec);
    }
    
    // 2. 簡單的航向修正直線行駛 (P 控制)
    double targetHeading = 0; // 設定目標方向為 0 度
    double kP = 0.5;          // 修正係數（根據底盤重量微調）

    while (true) {
        // 使用 rotation() 獲取累積角度，避免 359 跳回 0 的問題
        double currentHeading = Inertial1.rotation(degrees);
        double error = targetHeading - currentHeading;
        
        // 計算修正功率
        double turnPower = error * kP;

        // 將修正量疊加到底盤：左輪加速，右輪減速 (或反之)
        LeftMotor.spin(forward, 50 + turnPower, percent);
        RightMotor.spin(forward, 50 - turnPower, percent);

        wait(20, msec);
    }
}
```
</TabItem>
<TabItem value="cpp" label="PROS">

```cpp
/* * PROS 3 - 慣性感應器校準與電壓補償
 */

#include "main.h"

void autonomous() {
    pros::Imu imu_sensor(10); // 假設感應器在第 10 埠
    
    // 1. 重置與校準
    imu_sensor.reset();
    int time = 0;
    while (imu_sensor.is_calibrating()) {
        pros::delay(10);
        time += 10;
        if (time > 3000) break; // 防止死循環
    }

    // 2. 直線修正邏輯
    double target_heading = 0;
    double kP = 0.8; // PROS 建議使用較高的係數配合電壓控制

    while (true) {
        double current_heading = imu_sensor.get_rotation();
        double error = target_heading - current_heading;
        
        // 使用電壓控制 (Voltage) 會比百分比控制更精準
        int turn_voltage = (int)(error * kP * 100); 

        left_wheels.move_voltage(6000 + turn_voltage);
        right_wheels.move_voltage(6000 - turn_voltage);

        pros::delay(20);
    }
}
```
// 請在需要時指示生成 C++ 代碼實作

</TabItem>
</Tabs>

---

## **🎤 評審面談實戰 (Judges Interview)**

**Q1: 你們為什麼必須加裝慣性感應器？只用馬達編碼器不行嗎？**
*(考察重點：對感應器物理原理與打滑的理解)*

**🧐 回答範例：**
「在 Push Back 這種高對抗性的賽局中，被推擠是常態。馬達編碼器只能量測輪子轉動，無法感測**輪子打滑 (Wheel Slip)**。如果對手從側面撞擊，雖然輪子沒轉，但車身角度已偏，編碼器無法得知。慣性感應器提供獨立於輪子的絕對航向數據，讓我們能編寫出『防撞修正』程式，即使被撞歪也能自動復位。」

**Q2: 貴隊的自動程式有時很準，有時一啟動就撞牆，這是什麼原因？**
*(考察重點：工程除錯經驗與標準操作程序)*

**🧐 回答範例：**
「我們發現這是**初始化校準 (Initialization Calibration)** 的問題。有時操作員在開機時仍調整機器擺放位置，導致感應器在晃動中完成校準，造成零點偏移。我們現在在代碼中加入了校準保護邏輯，並訓練操作員嚴格執行『開機後手離開 3 秒』的標準程序，確保基準點永遠正確。」